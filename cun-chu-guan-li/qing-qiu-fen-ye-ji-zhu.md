# 请求分页技术
Linux系统采用了**请求分页**存储管理技术和对换技术(swap)

## 起因
由于虚拟内存的真实存储地址位于不同介质，需要有调度的功能，即当程序在内存中的分页运行需要使用的分页不在内存时候，要通过一定的调度方法把页表从虚拟内存的外存转移到内存。

基于基础的分页技术，二者根本区别在于请求分页提供虚拟存储器

## 引发的问题
1. 找不到外存产生缺页中断，对应需要有 **缺页中断** 的处理方案
@import "./.src/pic/imageK.png"
2. 在内存中放置页表也带来存取速度下降的矛盾
    - 维护一个专门的页表作为快速访问的硬件：[快表](https://baike.baidu.com/item/%E5%BF%AB%E8%A1%A8/19781679#0_1)
    - 程序局部化（工作集）：一个程序在一段时间内总是相对集中在一个有限地址空间的某个区域中执行
    
## 页面置换
缺页率p：表示缺页中断的概率

抖动：频繁地更换页面,以致系统的大部分时间花费在页面的调度和传输上

磁盘的读取时延
  1. 磁盘寻道时间（即磁头从当前磁道移至指定磁道所用的时间）
  2. 旋转延迟时间（即磁头从当前位置落到指定扇区开头所用的时间）
  3. 数据传输时间

### 常用的页面置换算法
  - <codepub>先进先出 FIFO </codepub>：淘汰在内存中停留时间最长（年龄最老）的一页，即先进入内存的页，先被换出。[Belady异常](https://baike.baidu.com/item/Belady%E5%BC%82%E5%B8%B8)
  - <codepub>最佳 OPT </codepub>：为调入新页面而必须预先淘汰某个老页面时，所选择的老页面应在将来不被使用，或者是在最远的将来才被访问。（较为理想的算法）
  - <codepub>最近最少使用 LRU </codepub>：以“最近的过去”作为“不久将来”的近似,**把最近最长一段时间里不曾使用的页面淘汰掉**。实质是：当需要置换一页时，选择在最近一段时间里最久没有使用过的页面予以淘汰
  - <codepub>最近未使用 NRU </codepub>

### 防止抖动
  - 采用局部置换策略
  - 利用工作集策略防止抖动
  - 挂起某些进程
  - 采用缺页频度法（Page Fault Frequency, PFF）

## Swap技术
1. 对换空间的分配
  - 对换设备是块设备，如经过构造的硬盘
  - 对换文件就是普通文件，但它们所占的磁盘空间必须是连续的
  - 通常，将对换分区类型设置为Linux Swap
  - 内核要为每个换出内存的进程建立对换文件
2. 进程对换
  - 对换守护进程kswapd的任务就是保证系统中有足够的空闲内存页。
  - 对换直接在对换设备和用户的内存空间之间进行，不通过缓冲机制。
  - 对换工作仅需局部进行。只需把该进程占用的全部内存空间复制到所分配的对换空间中，而不管未分配内存的那一部分虚拟空间。

Linux系统采用三级页表的方式，实现对管理的分级化
![](/.src/pic/imageL.png)
