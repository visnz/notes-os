# <codepub>[生产者-消费者问题](https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98)</codepub>

简述：资源生产者和消费者之间的调度问题，常见于交汇处的缓冲区

解决思路：生产者在缓冲区满的时候休眠（或放弃数据），等消费者开始消耗的时候，再唤醒生产者。反过来消费者再缓冲区空的时候休眠，生产者开始生产时候唤醒消费者。可以使用 信号灯法 或 忙碌等待 来解决：
- [信号灯法](https://zh.wikipedia.org/wiki/%E4%BF%A1%E8%99%9F%E6%A8%99)，在进程上放置信号灯，处理一次进程为+1，没被处理为-1。长时间没被处理的进程会被汇报给系统，用于调控死锁状态。
- 忙碌等待：通过循环对某一事物的监听。

# <codepub>[哲学家就餐问题](https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98)</codepub>

简述：五个哲学家围在一个圆形桌旁，各自面前有一盘意大利面，两盘意大利面中有一根叉子。哲学家们要么思考，要么吃面。哲学家吃面必须使用在它左右手两边的叉子。

问题：
  - 有可能每个人都左手拿叉，准备吃，都在等别人的右叉。（死锁）
  - 如果设定等吃超时为5秒，每隔五秒如果吃不到就就放下叉。（这样能解决死锁）但如果同时激发这五个人拿起左叉，就又要等待右叉，五秒后大家一起放下，又一起拿起来，最终持续下去，大家都吃不到。

解决思路：
  - 服务生：引入一个管理员，哲学家必须进过它允许才能就餐。
  - 资源分级（依序分配）：依次设定五个叉为12345，定义哲学家拿叉先拿小后拿大，吃完先放大再放小。

# <codepub>打瞌睡的理发师问题</codepub>
